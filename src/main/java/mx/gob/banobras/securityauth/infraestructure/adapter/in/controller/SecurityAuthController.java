package mx.gob.banobras.securityauth.infraestructure.adapter.in.controller;

/**
 * SecurityAuthController.java:
 * 
 * Clase controller taht expose services to autentication user.
 * 
 * @author Marcos Gonzalez
 * @version 1.0, 13/06/2024
 * @see Documento "MAR - Marco Arquitectonico de Referencia"
 * @since JDK 17
 */


import java.util.Date;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.ThreadContext;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;

import jakarta.servlet.http.HttpServletRequest;
import mx.gob.banobras.securityauth.application.port.in.ISecurityAuthCasoUsoService;
import mx.gob.banobras.securityauth.common.util.ConstantsSecurityAuth;
import mx.gob.banobras.securityauth.common.util.ErrorDetail;
import mx.gob.banobras.securityauth.infraestructure.config.dto.ErrorMessageDTO;
import mx.gob.banobras.securityauth.infraestructure.config.dto.LdapResponseDTO;
import mx.gob.banobras.securityauth.infraestructure.config.dto.SecurityAuthDTO;

@CrossOrigin(originPatterns = { "*" })
@RestController
public class SecurityAuthController implements ISecurityAuthController {

	/** Trace fo the application */
	Logger log = LogManager.getLogger(SecurityAuthController.class);

	/** Variable que contiene la url del ldap */
	@Value("${app.ldap.server}")
	String ldapServer;

	/** Injection variable of object HttpServletRequest */
	private HttpServletRequest httRequest;

	/** Injection variable para la interfaz iTokenizerInputPort */
	private final ISecurityAuthCasoUsoService iSecurityAuthInputPort;

	/** Consturctor de las interfaces que usa el controller */
	public SecurityAuthController(ISecurityAuthCasoUsoService iSecurityAuthInputPort, HttpServletRequest httRequest) {
		this.iSecurityAuthInputPort = iSecurityAuthInputPort;
		this.httRequest = httRequest;
	}

	/**
	 * Method to authenticated the user through LDAP
	 * 
	 * @param credentials    - Encrypted user credentials.
	 * @param app-name       - Name of the system that consume of service.
	 * @param consumer-id    - System layer that consumes the service.
	 * @param functional-id  - Functionality that consumes the service.
	 * @param transaction-id - Transaction identifier, generated by UUID.
	 * 
	 * @return back the object TokenizerResponseDTO with the token data
	 * @throws Exception send during process of authentication.
	 * 
	 */
	public ResponseEntity<LdapResponseDTO> ldapAuth(@RequestHeader(value = "credentials") String credentials,
			@RequestHeader(value = "app-name") String appName, @RequestHeader(value = "consumer-id") String consumerId,
			@RequestHeader(value = "functional-id") String functionalId,
			@RequestHeader(value = "transaction-id") String transactionId) {

		LdapResponseDTO ldapResponseDTO = null;
		SecurityAuthDTO securityAuthDTO = null;
		ErrorMessageDTO errorMessageDTO = null;

		try {

			/** Agrega parametros para que se muestren en el Log **/
			ThreadContext.put(ConstantsSecurityAuth.TRANSACTION_ID.getName(), transactionId);
			ThreadContext.put("ip", httRequest.getRemoteAddr());

			/** Verifica que las credenciales no esten vacias **/
			if (!credentials.isEmpty()) {
				log.info("Inicia autenticacion LDAP");
				securityAuthDTO = new SecurityAuthDTO(credentials, null, null, null, appName, consumerId, functionalId,
						transactionId, false);
				ldapResponseDTO = iSecurityAuthInputPort.authenticationLdap(securityAuthDTO);
			} else {
				errorMessageDTO = new ErrorMessageDTO();
				errorMessageDTO.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
				errorMessageDTO.setTimestamp(new Date());
				errorMessageDTO.setMessage(ConstantsSecurityAuth.MSG_CREDENTIALS_EMPTY.getName());
				/** Respuesta del servicio **/
				ldapResponseDTO = new LdapResponseDTO();
				ldapResponseDTO.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
				ldapResponseDTO.setErrorMessageDTO(errorMessageDTO);
			}
		} catch (Exception e) {
			e.printStackTrace();
			log.error(ConstantsSecurityAuth.EXCEPTION.getName(), e);
			errorMessageDTO = new ErrorMessageDTO();
			errorMessageDTO.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
			errorMessageDTO.setTimestamp(new Date());
			errorMessageDTO.setMessage(ConstantsSecurityAuth.MSG_ERROR_500.getName());
			errorMessageDTO.setDetail(ErrorDetail.getDetail(e));
			/** Respuesta del servicio */
			ldapResponseDTO = new LdapResponseDTO();
			ldapResponseDTO.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
			ldapResponseDTO.setErrorMessageDTO(errorMessageDTO);

		} finally {
			ThreadContext.clearStack();
			log.info("Finaliza autenticacion LDAP");
		}
		return new ResponseEntity<>(ldapResponseDTO, HttpStatus.valueOf(ldapResponseDTO.getStatusCode()));
	}

	/**
	 * Method to authenticated the user and password through LDAP
	 * 
	 * @param credentials    - Encrypted user credentials.
	 * @param app-name       - Name of the system that consume of service.
	 * @param consumer-id    - System layer that consumes the service.
	 * @param functional-id  - Functionality that consumes the service.
	 * @param transaction-id - Transaction identifier, generated by UUID.
	 * 
	 * @return back the object TokenizerResponseDTO with the token data
	 * @throws Exception send during process of authentication.
	 * 
	 */
	public ResponseEntity<LdapResponseDTO> ldapUserPwd(@RequestHeader(value = "credentials") String credentials,
			@RequestHeader(value = "app-name") String appName, @RequestHeader(value = "consumer-id") String consumerId,
			@RequestHeader(value = "functional-id") String functionalId,
			@RequestHeader(value = "transaction-id") String transactionId) {

		LdapResponseDTO ldapResponseDTO = null;
		SecurityAuthDTO securityAuthDTO = null;
		ErrorMessageDTO errorMessageDTO = null;

		try {

			/** Agrega parametros para que se muestren en el Log **/
			ThreadContext.put("transaction-id", transactionId);
			ThreadContext.put("ip", httRequest.getRemoteAddr());

			/** Verifica que las credenciales no esten vacias **/
			if (!credentials.isEmpty()) {
				log.info("Inicia autenticacion LDAP");
				securityAuthDTO = new SecurityAuthDTO(credentials, null, null, null, appName, consumerId, functionalId,
						transactionId, true);
				ldapResponseDTO = iSecurityAuthInputPort.authenticationLdap(securityAuthDTO);
			} else {
				errorMessageDTO = new ErrorMessageDTO();
				errorMessageDTO.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
				errorMessageDTO.setTimestamp(new Date());
				errorMessageDTO.setMessage(ConstantsSecurityAuth.MSG_CREDENTIALS_EMPTY.getName());
				/** Respuesta del servicio **/
				ldapResponseDTO = new LdapResponseDTO();
				ldapResponseDTO.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
				ldapResponseDTO.setErrorMessageDTO(errorMessageDTO);
			}
		} catch (Exception e) {
			e.printStackTrace();
			log.error(ConstantsSecurityAuth.EXCEPTION.getName(), e);
			errorMessageDTO = new ErrorMessageDTO();
			errorMessageDTO.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
			errorMessageDTO.setTimestamp(new Date());
			errorMessageDTO.setMessage(ConstantsSecurityAuth.MSG_ERROR_500.getName());
			errorMessageDTO.setDetail(ErrorDetail.getDetail(e));
			/** Respuesta del servicio */
			ldapResponseDTO = new LdapResponseDTO();
			ldapResponseDTO.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
			ldapResponseDTO.setErrorMessageDTO(errorMessageDTO);

		} finally {
			ThreadContext.clearStack();
			log.info("Finaliza autenticacion LDAP");
		}
		return new ResponseEntity<>(ldapResponseDTO, HttpStatus.valueOf(ldapResponseDTO.getStatusCode()));
	}

	/**
	 * Method to authenticated the user through of Token and LDAP
	 * 
	 * @param credentials    - Encrypted user credentials.
	 * @param token-auth     - Authentication Token.
	 * @param app-name       - Name of the system that consume of service.
	 * @param consumer-id    - System layer that consumes the service.
	 * @param functional-id  - Functionality that consumes the service.
	 * @param transaction-id - Transaction identifier, generated by UUID.
	 * 
	 * @return back the object TokenizerResponseDTO with the token data
	 * @throws Exception send during process of authentication.
	 * 
	 */
	public LdapResponseDTO ldapTokenAuth(@RequestHeader(value = "credentials") String credentials,
			@RequestHeader(value = "token-auth") String tokenAuth, @RequestHeader(value = "app-name") String appName,
			@RequestHeader(value = "consumer-id") String consumerId,
			@RequestHeader(value = "functional-id") String functionalId,
			@RequestHeader(value = "transaction-id") String transactionId) {

		LdapResponseDTO ldapResponseDTO = null;
		SecurityAuthDTO securityAuthDTO = null;
		ErrorMessageDTO errorMessageDTO = null;

		try {
			log.info("Inicia autenticacion Token-LDAP");

			// Agrega parametros para que se muestren en el Log
			ThreadContext.put(ConstantsSecurityAuth.TRANSACTION_ID.getName(), transactionId);
			ThreadContext.put(ConstantsSecurityAuth.IP.getName(), httRequest.getRemoteAddr());

			/** Verifica que las credenciales no esten vacias **/
			if (!credentials.isEmpty()) {
				securityAuthDTO = new SecurityAuthDTO(credentials, null, null, tokenAuth, appName, consumerId,
						functionalId, transactionId, false);
				ldapResponseDTO = iSecurityAuthInputPort.authenticationTokenLdap(securityAuthDTO);
			} else {
				errorMessageDTO = new ErrorMessageDTO();
				errorMessageDTO.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
				errorMessageDTO.setTimestamp(new Date());
				errorMessageDTO.setMessage(ConstantsSecurityAuth.MSG_CREDENTIALS_EMPTY.getName());
				/** Respuesta del servicio **/
				ldapResponseDTO = new LdapResponseDTO();
				ldapResponseDTO.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
				ldapResponseDTO.setErrorMessageDTO(errorMessageDTO);
			}

		} finally {
			ThreadContext.clearStack();

		}
		log.info("Finaliza autenticacion Token-LDAP");
		return ldapResponseDTO;
	}

	@Override
	public ResponseEntity<LdapResponseDTO> allDataUserLdap(@RequestHeader(value = "credentials") String credentials,
			@RequestHeader(value = "token-auth") String tokenAuth, @RequestHeader(value = "app-name") String appName,
			@RequestHeader(value = "consumer-id") String consumerId,
			@RequestHeader(value = "functional-id") String functionalId,
			@RequestHeader(value = "transaction-id") String transactionId) {

		LdapResponseDTO ldapResponseDTO = null;
		SecurityAuthDTO securityAuthDTO = null;
		ErrorMessageDTO errorMessage = null;

		log.info("Inicia allDataUserLdap");

		securityAuthDTO = new SecurityAuthDTO(credentials, null, null, tokenAuth, appName, consumerId, functionalId,
				transactionId, false);

		try {
			/** Agrega parametros para que se muestren en el Log */
			ThreadContext.put(ConstantsSecurityAuth.TRANSACTION_ID.getName(), transactionId);
			ThreadContext.put("ip", httRequest.getRemoteAddr());

			log.info("Inicia All User-LDAP");

			ldapResponseDTO = iSecurityAuthInputPort.allDataUserLdap(securityAuthDTO);

			// Valida el resultado en la generacio del token
			if (ldapResponseDTO.getStatusCode() == 200) {
				log.info("Los datos exsiten en LDAP");
				return new ResponseEntity<>(ldapResponseDTO, HttpStatus.OK);
			} else {
				log.info("Datos incorrectos");
				return new ResponseEntity<>(ldapResponseDTO, HttpStatus.valueOf(ldapResponseDTO.getStatusCode()));
			}
		} catch (IllegalArgumentException eil) {
			log.error(ConstantsSecurityAuth.ILLEGAL_ARG_EXCEPTION.getName(), eil);
			errorMessage = new ErrorMessageDTO(HttpStatus.INTERNAL_SERVER_ERROR.value(), new Date(), eil.getMessage());
			ldapResponseDTO = new LdapResponseDTO();
			ldapResponseDTO.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
			ldapResponseDTO.setErrorMessageDTO(errorMessage);
			return new ResponseEntity<>(ldapResponseDTO, HttpStatus.valueOf(ldapResponseDTO.getStatusCode()));
		} catch (Exception e) {
			log.error(ConstantsSecurityAuth.COMMUNICATION_EXCEPTION_LDAP.getName());
			log.error(ConstantsSecurityAuth.EXCEPTION.getName(), e);
			errorMessage = new ErrorMessageDTO(500, new Date(), "No hay conexión, Directorio Activo");
			ldapResponseDTO = new LdapResponseDTO();
			ldapResponseDTO.setStatusCode(HttpStatus.SERVICE_UNAVAILABLE.value());
			ldapResponseDTO.setErrorMessageDTO(errorMessage);
			return new ResponseEntity<>(ldapResponseDTO, HttpStatus.valueOf(ldapResponseDTO.getStatusCode()));
		} finally {
			ThreadContext.clearStack();
			log.info("Finaliza allDataUserLdap");
		}
	}
}
